<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Document</title>
    <!-- <script src="https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.js"></script>
    <link
      href="https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.css"
      rel="stylesheet"
    /> -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.5.1/mapbox-gl.js"></script>
    <link
      href="https://api.mapbox.com/mapbox-gl-js/v2.5.1/mapbox-gl.css"
      rel="stylesheet"
    />
    <style>
      body {
        padding: 0;
        margin: 0;
      }
      html,
      body,
      #map {
        height: 100%;
        width: 100vw;
      }

      /* #pickup_marker {
        transform: translate(50vw, 50vh) !important;
      } */
    </style>
  </head>
  <body>
    <div id="map"></div>

    <script>
      let waypoints;
      let allLines;
      let totalWayPoints;
      let pointsAdded;
      let PickupType;
      let geolocate_circle;
      let geolocate_arrow;
      let isDriver = false;
      let users_location;
      let device_coordinates;
      let previous_driver_location;

      // Driver Marker
      var carMarker = document.createElement("img");
      carMarker.style.width = "35px";
      carMarker.style.height = "35px";
      carMarker.setAttribute(
        "src",
        "https://test.qwickride.com/map/car-aerial.png"
      );

      // Rider App On Trip Marker
      var riderCarMarker = document.createElement("img");
      riderCarMarker.style.width = "35px";
      riderCarMarker.style.height = "35px";
      riderCarMarker.style.visibility = "hidden";
      riderCarMarker.setAttribute(
        "src",
        "https://test.qwickride.com/map/car-aerial.png"
      );

      var pickupMarker = document.createElement("div");
      pickupMarker.style.marginLeft = "-20px";
      pickupMarker.style.marginTop = "-40px";
      pickupMarker.style.display = "flex";
      pickupMarker.style.flexDirection = "column";
      pickupMarker.style.alignItems = "center";
      pickupMarker.setAttribute("id", "pickup_marker");

      var outerCircle = document.createElement("div");
      outerCircle.style.width = "30px";
      outerCircle.style.height = "30px";
      outerCircle.style.backgroundColor = "#080808";
      outerCircle.style.borderRadius = "30px";
      outerCircle.style.display = "flex";
      outerCircle.style.justifyContent = "center";
      outerCircle.style.alignItems = "center";

      var innerCircle = document.createElement("div");
      innerCircle.style.width = "10px";
      innerCircle.style.height = "10px";
      innerCircle.style.backgroundColor = "white";
      innerCircle.style.borderRadius = "10px";
      // innerCircle.s;

      var tipLine = document.createElement("div");
      tipLine.style.width = "2px";
      tipLine.style.height = "16px";
      tipLine.style.backgroundColor = "#080808";

      outerCircle.appendChild(innerCircle);
      pickupMarker.appendChild(outerCircle);
      pickupMarker.appendChild(tipLine);

      var pickupMakerIsVisible = false;

      const PickupMarkerControl = new mapboxgl.Marker({
        draggable: false,
        element: pickupMarker,
        pitchAlignment: "map",
        rotationAlignment: "map",
      });
      // .setLngLat([0, 0]);

      const DriverMarkerControl = new mapboxgl.Marker({
        color: "#000000",
        draggable: false,
        element: carMarker,
        pitchAlignment: "map",
        rotationAlignment: "map",
      });

      var endPoint = new mapboxgl.Marker({
        color: "#000000",
        draggable: false,
        pitchAlignment: "map",
        rotationAlignment: "map",
      });

      var startPoint = new mapboxgl.Marker({
        color: "#000000",
        draggable: false,
        pitchAlignment: "map",
        rotationAlignment: "map",
      });

      // document.getElementById("map").appendChild(pickupMarker);

      const geojson = {
        type: "FeatureCollection",
        features: [
          {
            type: "Feature",
            geometry: {
              type: "LineString",
              coordinates: [],
            },
          },
        ],
      };

      mapboxgl.accessToken =
        "pk.eyJ1IjoicXdpY2tyaWRlIiwiYSI6ImNrdnNxamozOTM1d3Yyb3RrZGRsY2oxaGQifQ.vwwjhiSqAE_Mi93HysJjfw";

      var map = new mapboxgl.Map({
        container: "map",
        style: "mapbox://styles/qwickride/ckvusc1cy3a6814pluz9xv0sw",
        attributionControl: false,
        // center: [-2.004445, 5.291557],
        zoom: 15,
      });

      map.addControl(
        new mapboxgl.NavigationControl({
          showZoom: false,
          // visualizePitch: false,
          showCompass: true,
        })
      );

      const geolocate = new mapboxgl.GeolocateControl({
        positionOptions: {
          enableHighAccuracy: true,
        },
        trackUserLocation: true,
        showUserHeading: true,
        showAccuracyCircle: false,
        fitBoundsOptions: { maxZoom: 18 },
      });

      map.addControl(geolocate, "bottom-right");
      geolocate.on("geolocate", (position) => {
        console.log("A geolocate event has occurred.");
        console.log(position.coords);
        device_coordinates = position.coords;
        if (!geolocate_circle) {
          geolocate_circle = document.getElementsByClassName(
            "mapboxgl-user-location-dot"
          )[0];
          geolocate_arrow = document.getElementsByClassName(
            "mapboxgl-user-location-heading"
          )[0];
          users_location = document.getElementsByClassName(
            "mapboxgl-user-location"
          )[0];
          users_location.appendChild(riderCarMarker);
          riderCarMarker.style.position = "absolute";
          riderCarMarker.style.left = "-10px";
          riderCarMarker.style.top = "-10px";
        }
        if (window.ReactNativeWebView)
          window.ReactNativeWebView.postMessage(
            JSON.stringify({
              current_location: {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
              },
              type: "User Location",
            })
          );
      });

      var geo = {
        /**
         * Calculate the bearing between two positions as a value from 0-360
         *
         * @param lat1 - The latitude of the first position
         * @param lng1 - The longitude of the first position
         * @param lat2 - The latitude of the second position
         * @param lng2 - The longitude of the second position
         *
         * @return int - The bearing between 0 and 360
         */
        bearing: function (lat1, lng1, lat2, lng2) {
          var dLon = this._toRad(lng2 - lng1);
          var y = Math.sin(dLon) * Math.cos(this._toRad(lat2));
          var x =
            Math.cos(this._toRad(lat1)) * Math.sin(this._toRad(lat2)) -
            Math.sin(this._toRad(lat1)) *
              Math.cos(this._toRad(lat2)) *
              Math.cos(dLon);
          var brng = this._toDeg(Math.atan2(y, x));
          return (brng + 360) % 360;
        },

        /**
         * Since not all browsers implement this we have our own utility that will
         * convert from degrees into radians
         *
         * @param deg - The degrees to be converted into radians
         * @return radians
         */
        _toRad: function (deg) {
          return (deg * Math.PI) / 180;
        },

        /**
         * Since not all browsers implement this we have our own utility that will
         * convert from radians into degrees
         *
         * @param rad - The radians to be converted into degrees
         * @return degrees
         */
        _toDeg: function (rad) {
          return (rad * 180) / Math.PI;
        },
      };

      /** Usage **/
      // var myInitialBearing = geo.bearing(0, 0, 45, 45);
      // console.log("Bearing ", myInitialBearing);

      function DrawLine(isDriver = false) {
        var point = allLines[pointsAdded];

        geojson.features[0].geometry.coordinates = allLines;
        // then update the map
        map.getSource("line").setData(geojson);

        const coordinates = geojson.features[0].geometry.coordinates;

        // Create a 'LngLatBounds' with both corners at the first coordinate.
        const bounds = new mapboxgl.LngLatBounds(
          coordinates[0],
          coordinates[0]
        );

        // Extend the 'LngLatBounds' to include every coordinate in the bounds result.
        for (const coord of coordinates) {
          bounds.extend(coord);
        }

        map.fitBounds(bounds, {
          padding: 20,
        });

        if (waypoints) {
          endPoint.setLngLat(allLines[allLines.length - 1]).addTo(map);
          PickupMarkerControl.setLngLat(allLines[0]);
          if (!isDriver) startPoint.setLngLat(allLines[0]).addTo(map);
        }
      }

      map.on("load", () => {
        console.log("A load event occurred.");
        geolocate.trigger();
        map.addSource("line", {
          type: "geojson",
          data: geojson,
        });

        map.addLayer({
          id: "line-animation",
          type: "line",
          source: "line",
          layout: {
            "line-cap": "round",
            "line-join": "round",
          },
          paint: {
            "line-color": "rgb(0,112,201)",
            "line-width": 10,
            "line-opacity": 0.8,
            "line-blur": 2,
          },
        });

        document.getElementsByClassName("mapboxgl-ctrl-logo")[0].href = "#";
      });

      if (navigator.appVersion.includes("Android")) {
        document.addEventListener("message", function (msg) {
          ProcessMapRequest(msg);
        });
      } else {
        window.addEventListener("message", function (msg) {
          ProcessMapRequest(msg);
          // alert(msg.data);
        });
      }

      function ProcessMapRequest(msg) {
        let result = JSON.parse(msg.data);
        switch (result.type) {
          case "Destination":
            geojson.features[0].geometry.coordinates = [];
            map.getSource("line").setData(geojson);
            waypoints = result.waypoints.data;
            allLines = waypoints.features[0].geometry.coordinates[0];
            totalWayPoints = allLines.length;
            pointsAdded = 0;
            DrawLine();
            break;
          case "Driver Destination":
            geojson.features[0].geometry.coordinates = [];
            map.getSource("line").setData(geojson);
            waypoints = result.waypoints.data;
            allLines = waypoints.features[0].geometry.coordinates[0];
            totalWayPoints = allLines.length;
            pointsAdded = 0;
            DrawLine(true);
            break;
          case "Driver Location":
            geojson.features[0].geometry.coordinates = [];
            map.getSource("line").setData(geojson);
            startPoint.remove();
            endPoint.remove();
            geolocate_circle.style.visibility = "hidden";
            geolocate_arrow.style.visibility = "hidden";
            if (previous_driver_location) {
              driver_bearing = geo.bearing(
                previous_driver_location.latitude,
                driver_location.longitude,
                result.driver_location.longitude,
                result.driver_location.latitude
              );
              DriverMarkerControl.setRotation(driver_bearing);
            }
            DriverMarkerControl.setLngLat([
              result.driver_location.longitude,
              result.driver_location.latitude,
            ]).addTo(map);
            previous_driver_location = result.driver_location;
            map.fitBounds({
              center: [
                [
                  result.driver_location.longitude,
                  result.driver_location.latitude,
                ],
                [device_coordinates.longitude, device_coordinates.latitude],
              ],
              zoom: 16,
            });
            break;
          case "Initial Pickup":
            let mapCenter = map.getCenter();
            PickupMarkerControl.setLngLat([mapCenter.lng, mapCenter.lat]);
            break;
          case "Pickup Location":
            PickupType = result.pickup_type;
            const pickUpCoords = PickupMarkerControl.getLngLat();
            let newCenter = [pickUpCoords.lng, pickUpCoords.lat];
            map.setZoom(18);
            map.setCenter(newCenter);
            PickupMarkerControl.setLngLat(newCenter).addTo(map);
            pickupMakerIsVisible = true;
            send_message_to_native({
              type: "Pickup Location",
              longitude: pickUpCoords.lng,
              latitude: pickUpCoords.lat,
              pickup_type: PickupType,
            });
            break;
          case "Confirm Pickup":
            PickupMarkerControl.remove();
            pickupMakerIsVisible = false;
            break;
          case "Driver On Trip":
            geolocate.trigger();
            break;
          case "On Trip":
            geolocate_circle.style.visibility = "hidden";
            geolocate_arrow.style.visibility = "hidden";
            riderCarMarker.style.visibility = "visible";
            DriverMarkerControl.remove();
            break;
          case "Reset CarMarker":
            riderCarMarker.style.visibility = "hidden";
            break;
          case "Current Location":
            startPoint.remove();
            endPoint.remove();
            geojson.features[0].geometry.coordinates = [];
            map.getSource("line").setData(geojson);
            geolocate.trigger();
            break;
          case "Start Trip":
            // startPoint.remove()
            endPoint.remove();
            geolocate.trigger();
            break;
          case "End Trip":
            // geolocate_circle.style.visibility = "visible";
            // geolocate_arrow.style.visibility = "visible";
            startPoint.remove();
            endPoint.remove();
            geojson.features[0].geometry.coordinates = [];
            map.getSource("line").setData(geojson);
            geolocate.trigger();
            break;
          case "DriverApp Instantiate":
            isDriver = true;
            const waitForCarMarkerToLoad = setInterval(() => {
              if (users_location) {
                // alert(users_location);
                geolocate_arrow.style.visibility = "hidden";
                geolocate_circle.style.visibility = "hidden";
                users_location.appendChild(carMarker);
                carMarker.style.position = "absolute";
                carMarker.style.left = "-10px";
                carMarker.style.top = "-10px";
                clearInterval(waitForCarMarkerToLoad);
              }
            }, 3000);
            break;
          default:
            // Reset Map
            startPoint.remove();
            endPoint.remove();
            if (!isDriver) {
              DriverMarkerControl.remove();
              geolocate_circle.style.visibility = "visible";
              geolocate_arrow.style.visibility = "visible";
              riderCarMarker.style.visibility = "hidden";
            }
            geojson.features[0].geometry.coordinates = [];
            map.getSource("line").setData(geojson);
            geolocate.trigger();
            break;
        }
      }

      map.on("moveend", () => {
        console.log("A dragend event occurred.");
        if (pickupMakerIsVisible) {
          let lngLat = map.getCenter();
          send_message_to_native({
            type: "Pickup Location",
            longitude: lngLat.lng,
            latitude: lngLat.lat,
            pickup_type: PickupType,
          });
        }
      });

      map.on("movestart", () => {
        console.log("A movestart` event occurred.");
        if (pickupMakerIsVisible) {
          let lngLat = map.getCenter();
          send_message_to_native({
            type: "Pickup Location",
            longitude: lngLat.lng,
            latitude: lngLat.lat,
            pickup_type: PickupType,
          });
        }
      });

      map.on("move", () => {
        // console.log("A move event occurred.");
        if (pickupMakerIsVisible) {
          const lngLat = map.getCenter();
          PickupMarkerControl.setLngLat([lngLat.lng, lngLat.lat]).addTo(map);
        }
      });

      function send_message_to_native(data) {
        window.ReactNativeWebView.postMessage(JSON.stringify(data));
      }
    </script>
  </body>
</html>
